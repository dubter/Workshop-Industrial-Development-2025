### **Домашнее задание: Развёртывание распределённой системы логирования и хранения с резервным копированием**

1. **Создать пользовательское веб-приложение (API)**  
   Приложение должно реализовать следующие REST-эндпоинты:
   - `GET /` — возвращает строку `"Welcome to the custom app"`
   - `GET /status` — возвращает JSON `{"status": "ok"}`
   - `POST /log` — принимает JSON `{"message": "some log"}` и записывает его в файл `/app/logs/app.log`
   - `GET /logs` — возвращает содержимое файла `/app/logs/app.log`

   Приложение должно:
   - Писать логи в `/app/logs/app.log`
   - Использовать конфигурационные параметры (например, уровень логирования, порт, заголовок приветствия) из ConfigMap

2. **Развернуть приложение как Pod для начального теста**
   - Написать Dockerfile для приложения
   - Создать Pod, монтирующий:
      - `emptyDir` volume в `/app/logs`
      - ConfigMap с настройками в `/app/config` (или через переменные окружения)

3. **Развернуть приложение как Deployment**
   - Создать Deployment с 3 репликами
   - Настроить монтирование `emptyDir` для логов
   - Обновить Deployment, чтобы изменения в ConfigMap автоматически применялись
   - Проверить через Service и `kubectl port-forward`, что API работает

4. **Создать Service для балансировки нагрузки**
   - ClusterIP-сервис, направляющий трафик на поды приложения
   - Проверить: `curl http://<service-name>/logs` и `curl -X POST http://<service-name>/log -d '{"message": "test"}'`
   - Убедиться, что запросы распределяются между подами

5. **Развернуть DaemonSet с log-agent**
   - DaemonSet должен:
      - Быть запущен на каждом узле
      - Собирать логи приложения из подов (через `hostPath` или `emptyDir`, при наличии доступа)
      - Перенаправлять логи во stdout или сохранять локально на узле
   - Проверить, что `kubectl logs <log-agent-pod>` содержит записи из `app.log`

6. **Развернуть CronJob для архивирования логов**
   - CronJob должен запускаться раз в 10 минут
   - Команда: `tar -czf /tmp/app-logs-<timestamp>.tar.gz /app/logs/`
   - Логи берутся с сервисов приложения через HTTP API `/logs` (например, `curl`) или из общей директории, если доступна
   - Результат сохраняется в контейнере в `/tmp` (внутри пода CronJob)

7. **Создать единый bash-скрипт `deploy.sh` для автоматического развёртывания всей системы**
   - Скрипт должен:
      - Создавать все необходимые **ConfigMap**, **Pod**, **Deployment**, **Service**, **DaemonSet**, **StatefulSet**, **CronJob** и другие объекты
      - Использовать команды `kubectl apply -f` с заранее подготовленными YAML-файлами
      - Ожидать готовности ключевых компонентов
   - В **README.md** проекта добавьте команду для запуска скрипта из терминала


# Решение

Данный проект представляет собой распределенную систему логирования с резервным копированием, развернутую в Kubernetes.

## Компоненты системы

- **Пользовательское веб-приложение**: обрабатывает REST-запросы и сохраняет логи
- **Deployment с 3 репликами**: обеспечивает высокую доступность приложения
- **Service**: балансирует нагрузку между подами
- **DaemonSet**: агенты для сбора логов на каждом узле
- **CronJob**: периодически архивирует логи

## Запуск системы

Для развертывания всей системы выполните:

```bash
./deploy.sh
```

# Тестирование

## Проброс порта сервиса
`kubectl port-forward svc/app-service 8080:80 &`

## Тестирование API
```
curl http://localhost:8080/
curl http://localhost:8080/status
curl -X POST http://localhost:8080/log -d '{"message": "Test log"}'
curl http://localhost:8080/logs
```

# Логи приложения
`kubectl logs deploy/app-deployment`

# Логи агентов сбора логов
`kubectl logs -l name=log-agent`

# Результаты архивирования (после запуска CronJob)
`kubectl logs job/log-archiver-<timestamp>`

# Архитектура
* Приложение сохраняет логи в /app/logs/app.log
* Log-агенты (DaemonSet) собирают логи со всех узлов
* CronJob архивирует логи каждые 10 минут
* Конфигурация управляется через ConfigMap
